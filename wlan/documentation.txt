Here you will find some infos needed to build a wlan driver


#define ETH_ALEN 6
#define IFNAMSIZ 16

enum {
    MSG_EXCESSIVE, MSG_MSGDUMP, MSG_DEBUG, MSG_INFO, MSG_WARNING, MSG_ERROR
};

struct wpa_driver_scan_filter {
        uint8_t ssid[32];
        size_t ssid_len;
};

struct wowlan_triggers {
    uint8_t any;
    uint8_t disconnect;
    uint8_t magic_pkt;
    uint8_t gtk_rekey_failure;
    uint8_t eap_identity_req;
    uint8_t four_way_handshake;
    uint8_t rfkill_release;
};

struct wpa_driver_capa {
#define WPA_DRIVER_CAPA_KEY_MGMT_WPA        0x00000001
#define WPA_DRIVER_CAPA_KEY_MGMT_WPA2       0x00000002
#define WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK    0x00000004
#define WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK   0x00000008
#define WPA_DRIVER_CAPA_KEY_MGMT_WPA_NONE   0x00000010
#define WPA_DRIVER_CAPA_KEY_MGMT_FT     0x00000020
#define WPA_DRIVER_CAPA_KEY_MGMT_FT_PSK     0x00000040
#define WPA_DRIVER_CAPA_KEY_MGMT_WAPI_PSK   0x00000080
    unsigned int key_mgmt;

#define WPA_DRIVER_CAPA_ENC_WEP40   0x00000001
#define WPA_DRIVER_CAPA_ENC_WEP104  0x00000002
#define WPA_DRIVER_CAPA_ENC_TKIP    0x00000004
#define WPA_DRIVER_CAPA_ENC_CCMP    0x00000008
#define WPA_DRIVER_CAPA_ENC_WEP128  0x00000010
#define WPA_DRIVER_CAPA_ENC_GCMP    0x00000020
#define WPA_DRIVER_CAPA_ENC_GCMP_256    0x00000040
#define WPA_DRIVER_CAPA_ENC_CCMP_256    0x00000080
#define WPA_DRIVER_CAPA_ENC_BIP     0x00000100
#define WPA_DRIVER_CAPA_ENC_BIP_GMAC_128    0x00000200
#define WPA_DRIVER_CAPA_ENC_BIP_GMAC_256    0x00000400
#define WPA_DRIVER_CAPA_ENC_BIP_CMAC_256    0x00000800
#define WPA_DRIVER_CAPA_ENC_GTK_NOT_USED    0x00001000
    unsigned int enc;
#define WPA_DRIVER_AUTH_OPEN        0x00000001
#define WPA_DRIVER_AUTH_SHARED      0x00000002
#define WPA_DRIVER_AUTH_LEAP        0x00000004
    unsigned int auth;

/* Driver generated WPA/RSN IE */
#define WPA_DRIVER_FLAGS_DRIVER_IE  0x00000001
/* Driver needs static WEP key setup after association command */
#define WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC 0x00000002
/* Driver takes care of all DFS operations */
#define WPA_DRIVER_FLAGS_DFS_OFFLOAD            0x00000004
/* Driver takes care of RSN 4-way handshake internally; PMK is configured with
 * struct wpa_driver_ops::set_key using alg = WPA_ALG_PMK */
#define WPA_DRIVER_FLAGS_4WAY_HANDSHAKE 0x00000008
#define WPA_DRIVER_FLAGS_WIRED      0x00000010
/* Driver provides separate commands for authentication and association (SME in
 * wpa_supplicant). */
#define WPA_DRIVER_FLAGS_SME        0x00000020
/* Driver supports AP mode */
#define WPA_DRIVER_FLAGS_AP     0x00000040
/* Driver needs static WEP key setup after association has been completed */
#define WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC_DONE  0x00000080
/* Driver supports dynamic HT 20/40 MHz channel changes during BSS lifetime */
#define WPA_DRIVER_FLAGS_HT_2040_COEX           0x00000100
/* Driver supports concurrent P2P operations */
#define WPA_DRIVER_FLAGS_P2P_CONCURRENT 0x00000200
/*
 * Driver uses the initial interface as a dedicated management interface, i.e.,
 * it cannot be used for P2P group operations or non-P2P purposes.
 */
#define WPA_DRIVER_FLAGS_P2P_DEDICATED_INTERFACE    0x00000400
/* This interface is P2P capable (P2P GO or P2P Client) */
#define WPA_DRIVER_FLAGS_P2P_CAPABLE    0x00000800
/* Driver supports station and key removal when stopping an AP */
#define WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT        0x00001000
/*
 * Driver uses the initial interface for P2P management interface and non-P2P
 * purposes (e.g., connect to infra AP), but this interface cannot be used for
 * P2P group operations.
 */
#define WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P       0x00002000
/*
 * Driver is known to use sane error codes, i.e., when it indicates that
 * something (e.g., association) fails, there was indeed a failure and the
 * operation does not end up getting completed successfully later.
 */
#define WPA_DRIVER_FLAGS_SANE_ERROR_CODES       0x00004000
/* Driver supports off-channel TX */
#define WPA_DRIVER_FLAGS_OFFCHANNEL_TX          0x00008000
/* Driver indicates TX status events for EAPOL Data frames */
#define WPA_DRIVER_FLAGS_EAPOL_TX_STATUS        0x00010000
/* Driver indicates TX status events for Deauth/Disassoc frames */
#define WPA_DRIVER_FLAGS_DEAUTH_TX_STATUS       0x00020000
/* Driver supports roaming (BSS selection) in firmware */
#define WPA_DRIVER_FLAGS_BSS_SELECTION          0x00040000
/* Driver supports operating as a TDLS peer */
#define WPA_DRIVER_FLAGS_TDLS_SUPPORT           0x00080000
/* Driver requires external TDLS setup/teardown/discovery */
#define WPA_DRIVER_FLAGS_TDLS_EXTERNAL_SETUP        0x00100000
/* Driver indicates support for Probe Response offloading in AP mode */
#define WPA_DRIVER_FLAGS_PROBE_RESP_OFFLOAD     0x00200000
/* Driver supports U-APSD in AP mode */
#define WPA_DRIVER_FLAGS_AP_UAPSD           0x00400000
/* Driver supports inactivity timer in AP mode */
#define WPA_DRIVER_FLAGS_INACTIVITY_TIMER       0x00800000
/* Driver expects user space implementation of MLME in AP mode */
#define WPA_DRIVER_FLAGS_AP_MLME            0x01000000
/* Driver supports SAE with user space SME */
#define WPA_DRIVER_FLAGS_SAE                0x02000000
/* Driver makes use of OBSS scan mechanism in wpa_supplicant */
#define WPA_DRIVER_FLAGS_OBSS_SCAN          0x04000000
/* Driver supports IBSS (Ad-hoc) mode */
#define WPA_DRIVER_FLAGS_IBSS               0x08000000
/* Driver supports radar detection */
#define WPA_DRIVER_FLAGS_RADAR              0x10000000
/* Driver supports a dedicated interface for P2P Device */
#define WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE       0x20000000
/* Driver supports QoS Mapping */
#define WPA_DRIVER_FLAGS_QOS_MAPPING            0x40000000
/* Driver supports CSA in AP mode */
#define WPA_DRIVER_FLAGS_AP_CSA             0x80000000
    unsigned int flags;

    int max_scan_ssids;
    int max_sched_scan_ssids;
    int sched_scan_supported;
    int max_match_sets;

    /**
     * max_remain_on_chan - Maximum remain-on-channel duration in msec
     */
    unsigned int max_remain_on_chan;

    /**
     * max_stations - Maximum number of associated stations the driver
     * supports in AP mode
     */
    unsigned int max_stations;
    /* Driver Probe Response offloading support for WPS ver. 1 */
#define WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS       0x00000001
/* Driver Probe Response offloading support for WPS ver. 2 */
#define WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS2      0x00000002
/* Driver Probe Response offloading support for P2P */
#define WPA_DRIVER_PROBE_RESP_OFFLOAD_P2P       0x00000004
/* Driver Probe Response offloading support for IEEE 802.11u (Interworking) */
#define WPA_DRIVER_PROBE_RESP_OFFLOAD_INTERWORKING  0x00000008
    unsigned int probe_resp_offloads;

    unsigned int max_acl_mac_addrs;

    /**
     * Number of supported concurrent channels
     */
    unsigned int num_multichan_concurrent;

    /**
     * extended_capa - extended capabilities in driver/device
     *
     * Must be allocated and freed by driver and the pointers must be
     * valid for the lifetime of the driver, i.e., freed in deinit()
     */
    const uint8_t *extended_capa, *extended_capa_mask;
    unsigned int extended_capa_len;

    struct wowlan_triggers wowlan_triggers;
};

enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED,
    NL80211_IFTYPE_ADHOC,
    NL80211_IFTYPE_STATION,
    NL80211_IFTYPE_AP,
    NL80211_IFTYPE_AP_VLAN,
    NL80211_IFTYPE_WDS,
    NL80211_IFTYPE_MONITOR,
    NL80211_IFTYPE_MESH_POINT,
    NL80211_IFTYPE_P2P_CLIENT,
    NL80211_IFTYPE_P2P_GO,
    NL80211_IFTYPE_P2P_DEVICE,

    /* keep last */
    NUM_NL80211_IFTYPES,
    NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
};

enum scan_states {
        NO_SCAN, SCAN_REQUESTED, SCAN_STARTED, SCAN_COMPLETED,
        SCAN_ABORTED, SCHED_SCAN_STARTED, SCHED_SCAN_STOPPED,
        SCHED_SCAN_RESULTS
};

struct nl80211_global {
    struct dl_list interfaces;
    int if_add_ifindex;
    uint64_t if_add_wdevid;
    int if_add_wdevid_set;
    struct netlink_data *netlink;
    struct nl_cb *nl_cb;
    struct nl_handle *nl;
    int nl80211_id;
    int ioctl_sock; /* socket for ioctl() use */

    struct nl_handle *nl_event;
};

struct dl_list
{
  int _v1;
  int field_4;
};


struct wpa_driver_nl80211_data {
    struct nl80211_global *global;
    struct dl_list list;
    struct dl_list wiphy_list;
    char phyname[32];
    void *ctx;
    int ifindex;
    int if_removed;
    int if_disabled;
    int ignore_if_down_event;
    struct rfkill_data *rfkill;
    struct wpa_driver_capa capa;
    uint8_t *extended_capa, *extended_capa_mask;
    unsigned int extended_capa_len;
    int has_capability;

    int operstate;

    int scan_complete_events;
    scan_states scan_state;

    struct nl_cb *nl_cb;

    uint8_t auth_bssid[6];
    uint8_t auth_attempt_bssid[6];
    uint8_t bssid[6];
    uint8_t prev_bssid[6];
    int associated;
    uint8_t ssid[32];
    size_t ssid_len;
    enum nl80211_iftype nlmode;
    enum nl80211_iftype ap_scan_as_station;
    unsigned int assoc_freq;

    int monitor_sock;
    int monitor_ifidx;
    int monitor_refcount;

    unsigned int disabled_11b_rates:1;
    unsigned int pending_remain_on_chan:1;
    unsigned int in_interface_list:1;
    unsigned int device_ap_sme:1;
    unsigned int poll_command_supported:1;
    unsigned int data_tx_status:1;
    unsigned int scan_for_auth:1;
    unsigned int retry_auth:1;
    unsigned int use_monitor:1;
    unsigned int ignore_next_local_disconnect:1;
    unsigned int ignore_next_local_deauth:1;
    unsigned int allow_p2p_device:1;
    unsigned int hostapd:1;
    unsigned int start_mode_ap:1;
    unsigned int start_iface_up:1;
    unsigned int test_use_roc_tx:1;
    unsigned int ignore_deauth_event:1;
    unsigned int dfs_vendor_cmd_avail:1;
    unsigned int have_low_prio_scan:1;
    uint64_t remain_on_chan_cookie;
    uint64_t send_action_cookie;

    unsigned int last_mgmt_freq;

    struct wpa_driver_scan_filter *filter_ssids;
    size_t num_filter_ssids;

    struct i802_bss *first_bss;

    int eapol_tx_sock;

    int eapol_sock; /* socket for EAPOL frames */

    int default_if_indices[16];
    int *if_indices;
    int num_if_indices;

    /* From failed authentication command */
    int auth_freq;
    uint8_t auth_bssid_[6];
    uint8_t auth_ssid[32];
    size_t auth_ssid_len;
    int auth_alg;
    uint8_t *auth_ie;
    size_t auth_ie_len;
    uint8_t auth_wep_key[4][16];
    size_t auth_wep_key_len[4];
    int auth_wep_tx_keyidx;
    int auth_local_state_change;
    int auth_p2p;
};

    
    

struct i802_bss {
    struct wpa_driver_nl80211_data *drv;
    struct i802_bss *next;
    int ifindex;
    uint64_t wdev_id;
    char ifname[6 + 1];
    char brname[6];
    unsigned int beacon_set:1;
    unsigned int added_if_into_bridge:1;
    unsigned int added_bridge:1;
    unsigned int in_deinit:1;
    unsigned int wdev_id_set:1;
    unsigned int added_if:1;
    unsigned int static_ap:1;

    uint8_t addr[6];

    int freq;
    int bandwidth;
    int if_dynamic;

    void *ctx;
    struct nl_handle *nl_preq, *nl_mgmt;
    struct nl_cb *nl_cb;

    struct nl80211_wiphy_data *wiphy_data;
    struct dl_list wiphy_list;
};
